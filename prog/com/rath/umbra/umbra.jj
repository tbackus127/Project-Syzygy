options
{
  STATIC = false;
  COMMON_TOKEN_ACTION = true;
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

// --------------------------------------------------------------------------------------------------------------------
// Parser Declaration

PARSER_BEGIN(UmbraCmp)

package com.rath.umbra;

import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class UmbraCmp {

  public Program parse() {
    
    try {
      return PROGRAM();
    } catch (TokenMgrError tme) {
      System.err.println(tme.getMessage);
      return null;
    } catch (ParseException pe) {
      System.err.println(pe.getMessage);
      return null;
    }
    
  }

}


PARSER_END(UmbraCmp)

// --------------------------------------------------------------------------------------------------------------------
// Tokens

TOKEN_MGR_DECLS: {
  void CommonTokenAction(Token t) {
    System.out.println("Token: " + t.image);
  }
}

SKIP: {
  " "| "\t" | "\n" | "\r" | <"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}





// --------------------------------------------------------------------------------------------------------------------
// Operators

TOKEN: {
  
  <OP_ASL: "<<<" >
|
  <OP_ASR: ">>>" >
|
  <OP_LTE: "<=" >
|
  <OP_GTE: ">=" >
|
  <OP_LSL: "<<" >
|
  <OP_LSR: ">>" >
|
  <OP_EXCL: "!" >
|
  <OP_PLUS: "+" >
|
  <OP_HYPHEN: "-" >
|
  <OP_ASTER: "*" >
|
  <OP_EQUAL: "=" >
|
  <OP_SLASH: "/" >
|
  <OP_PERCENT: "%" >
|
  <OP_CARET: "^" >
|
  <OP_GT: ">" >
|
  <OP_LT: "<" >
|
  <SEP_LPAREN: "(" >
|
  <SEP_RPAREN: ")" >
  
}

// --------------------------------------------------------------------------------------------------------------------
// Separators / Misc tokens
TOKEN: {
  
  "{" | "}" | "[" | "]" | "," | ";" | ":" | "\"" | "@" | "."
  
}

// --------------------------------------------------------------------------------------------------------------------
// Reserved Words
TOKEN: {
  
  "var" | "set" | "param" | "if" | "else" | "main" | "func" | "for" | "return" | "while"
  
}

// --------------------------------------------------------------------------------------------------------------------
// Values

TOKEN: {
  
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])*  >
|  
  < REFERENCE: "@" <IDENTIFIER> ":" <IDENTIFIER> >
|
  < LIT_GENERAL: <LIT_NUMBER> | <LIT_CHAR> | <LIT_STRING> >
|
  < LIT_NUMBER: <LIT_DECIMAL> | <LIT_HEX> >
|
  < #LIT_DECIMAL: ["1"-"9"] (["0"-"9"])* >
|
  < #LIT_HEX: "0x" (["0"-"9","a"-"f","A"-"F"]){1,4} >
|
  < LIT_CHAR:
    "'"
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "'"
  >
|
  < LIT_STRING:
    "\""
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "\""
  >
  
  
}


// --------------------------------------------------------------------------------------------------------------------
// Grammar

Program PROGRAM() :
{
  List<ParamDeclaration> paramDeclList = new ArrayList<ParamDeclaration>();
  List<FunctionDeclaration> funcDeclList = new ArrayList<FunctionDeclaration>();
  MainDeclaration mainDecl;
  ParamDeclaration pd;
  FunctionDeclaration fd;
}
{

  ( pd = PARAM_DECLARATION() { paramDeclList.add(pd); } )*
  ( mainDecl = MAIN_DECLARATION() )
  ( fd = FUNCTION_DECLARATION() {funcDeclList.add(fd); } )*
  <EOF>
  { return new Program(paramDeclList, mainDecl, funcDeclList); }
}

MainDeclaration MAIN_DECLARATION() :
{
  StatementList body;
}
{
  "main" "{"
    ( body = STATEMENT_LIST() )
  "}"
  
  { return new MainDeclaration(body); }
}

FunctionDeclaration FUNCTION_DECLARATION() :
{
  Token name;
  ArgList argList;
  StatementList body;
}
{
  "func" name = <IDENTIFIER> "(" argList = ARG_LIST() ")" "{"
    body = STATEMENT_LIST()
  "}"
  
  { return new FunctionDeclaration(name, argList, body); }
}

ParamDeclaration PARAM_DECLARATION() :
{
  Token id;
  Token value;
}
{
 
  "param" (id = <IDENTIFIER>) "=" (value = <LIT_GENERAL>) ";"
  
  { return new ParamDeclaration(id, value); }
}

ArgList ARG_LIST() :
{
  ArgListHead head;
  List<ArgListTail> tail = new ArrayList<ArgListTail>();
  ArgListTail t;
}
{
  head = ARG_LIST_HEAD() ( t = ARG_LIST_TAIL() { tail.add(t); } )*
  
  { return new ArgList(head, tail); }
}

ArgListHead ARG_LIST_HEAD() :
{
  Token id;
}
{
  "var" id = <IDENTIFIER>
  
  { return new Variable(id.image()); }
}

ArgListTail ARG_LIST_TAIL() :
{
  Token id;
}
{
  "," "var" id = <IDENTIFIER>
  
  { return new Variable(id.image()); }
}

StatementList STATEMENT_LIST() :
{
  List<Statement> list = new ArrayList<Statement>();
  Statement st;
}
{
  
  (LOOKAHEAD(2) st = STATEMENT() { list.add(st); } )+
  
  { return new StatementList(list); }
}

Statement STATEMENT() :
{
  Operation operation;
  ControlStructure controlStructure;
}
{
  ( operation = OPERATION() )
  { return new Operation(operation); }
|
  ( controlStructure = CONTROL_STRUCTURE() )
  { return new ControlStructure(controlStructure); }
}

Operation OPERATION(): 
{
  SetOperation setOperation;
  VarDeclaration varDeclaration;
  VarInitialization varInitialization;
  ReturnOperation returnOperation;
  Expression expr;
}
{
  (
    LOOKAHEAD(3) setOperation = SET_OPERATION()
    { return new SetOperation(setOperation); }
  |
    LOOKAHEAD(3) varDeclaration = VAR_DECLARATION()
    { return new VarDeclaration(varDeclaration); }
  |
    varInitialization = VAR_INITIALIZATION()
    { return new VarInitialization(varInitialization); }
  |
    returnOperation = RETURN_OPERATION()
    { return new ReturnOperation(returnOperation); }
  |
    expr = EXPRESSION()
    { return new Expression(expr); }
  )
  ";"
}

ControlStructure CONTROL_STRUCTURE() :
{
   ConditionalBranch conditionalBranch;
   WhileLoop whileLoop;
   ForLoop forLoop;
}
{
  conditionalBranch = CONDITIONAL_BRANCH()
  { return new ConditionalBranch(conditionalBranch); }
|
  whileLoop = WHILE_LOOP()
  { return new WhileLoop(whileLoop); }
|
  forLoop = FOR_LOOP()
  { return new ForLoop(forLoop); }
}

SetOperation SET_OPERATION() :
{
  Token id;
  Expression expr;
}
{
  "set" id = <IDENTIFIER> "=" expr = EXPRESSION()
  { return new SetOperation(id, expr); }
}

VarDeclaration VAR_DECLARATION() :
{
  Token id;
}
{
  "var" id = <IDENTIFIER>
  { return new Variable(id.image()); }
}

VarInitialization VAR_INITIALIZATION() :
{
  Token id;
  Expression expr;
}
{
  "var" id = <IDENTIFIER> "=" expr = EXPRESSION()
  { return new VarInitialization(id, expr); }
}

ReturnOperation RETURN_OPERATION() :
{
  Expression expr;
}
{
  "return" (expr = EXPRESSION())?
  { return new ReturnOperation(expr); }
}

ConditionalBranch CONDITIONAL_BRANCH() :
{
  Expression ifExpr;
  List<Expression> elsifExprList = new ArrayList<Expression>();
  Expression elseExpr;
  
  StatementList ifBody;
  List<StatementList> elsifStatementBodyList = new ArrayList<StatementList>();
  Expression elseBody;
  
  Expression elsifExpr;
  StatementList elsifStatementList;
}
{
  "if" "(" ifExpr = EXPRESSION() ")" "{"
    ifBody = STATEMENT_LIST()
  "}"
  
  
  ( LOOKAHEAD(2) 
    "else" "if" "(" elsifExpr = EXPRESSION() { elsifExprList.add(elsifExpr); } ")" "{"
      elsifStatementList = STATEMENT_LIST() { elsifStatementBodyList.add(elsifStatementList); }
    "}"
  )*
  
  (
    "else" "(" elseExpr = EXPRESSION() ")" "{"
      elseBody = STATEMENT_LIST()
    "}"
  )?
  
  { return new ConditionalBranch(ifExpr, elsifExprList, elseExpr, ifBody, elsifStatementBodyList, elseBody); }
}

WhileLoop WHILE_LOOP() :
{
  Expression conditional;
  StatementList body;
}
{
  "while" "(" conditional = EXPRESSION() ")" "{"
    body = STATEMENT_LIST()
  "}"
  
  { return new WhileLoop(conditional, body); }
}

ForLoop FOR_LOOP() :
{
  VarInitialization init;
  Expression conditional;
  SetOperation setOperation;
  StatementList body;
}
{
  "for" "(" (init = VAR_INITIALIZATION())? ";" conditional = EXPRESSION() ";" setOperation = SET_OPERATION() ")" "{"
    body = STATEMENT_LIST()
  "}"
  
  { return new ForLoop(init, conditional, setOperation, body); }
}

Expression EXPRESSION() :
{
  Token op;
  ExpressionHead head;
  Expression tail;
}
{
  op = <SEP_LPAREN> tail = EXPRESSION() <SEP_RPAREN>
|
  op = <OP_EXCL> tail = EXPRESSION()
|  
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_ASL> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_ASR> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_LSL> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_LSR> tail = EXPRESSION()
|  
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_LTE> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_GTE> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_LT> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_GT> tail = EXPRESSION()
|  
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_PLUS> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_HYPHEN> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_ASTER> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_SLASH> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_CARET> tail = EXPRESSION()
|
  LOOKAHEAD(3) head = EXPRESSION_HEAD() op = <OP_PERCENT> tail = EXPRESSION()
  
  { return new Expression(op, head, tail); }
}

ExpressionHead EXPRESSION_HEAD() :
{
  FunctionCall func;
  Token id;
  Token referenceName;
  Token value;
}
{
  func = FUNCTION_CALL()
  { return new FunctionCall(func); }
|
  id = <IDENTIFIER>
  { return new Variable(id.getImage()); }
|
  referenceName = <REFERENCE>
  { return new Variable(referenceName.getImage()); }
|
  value = <LIT_GENERAL>
  { return new Variable(value.getImage()); }
}

FunctionCall FUNCTION_CALL() :
{
  Token id;
  ValueList valueList;
}
{
  "." id = <IDENTIFIER> "(" ( valueList = VALUE_LIST() )? ")"
  { return new FunctionCall(id, valueList); }
}

ValueList VALUE_LIST() :
{
  Expression exprHead;
  List<Expression> exprList;
  Expression exprTail;
}
{
  exprHead = EXPRESSION() ("," exprTail = EXPRESSION() { exprList.add(exprTail); } )*
  { return new ValueList(exprHead, exprList); }
}

