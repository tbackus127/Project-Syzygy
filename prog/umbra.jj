options
{
  STATIC = false;
  COMMON_TOKEN_ACTION = true;
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

// --------------------------------------------------------------------------------------------------------------------
// Parser Declaration

PARSER_BEGIN(UmbraCmp)

import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class UmbraCmp {

  public Program parse() {
    
    try {
      return Program();
    } catch (TokenMgrError tme) {
      System.err.println(tme.getMessage);
      return null;
    } catch (ParseException pe) {
      System.err.println(pe.getMessage);
      return null;
    }
    
  }

}


PARSER_END(UmbraCmp)

// --------------------------------------------------------------------------------------------------------------------
// Tokens

TOKEN_MGR_DECLS: {
  void CommonTokenAction(Token t) {
    System.out.println("Token: " + t.image);
  }
}

SKIP: {
  " "| "\t" | "\n" | "\r" | <"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}





// --------------------------------------------------------------------------------------------------------------------
// Operators

TOKEN: {
  
  "<<<", ">>>", "<=", ">=", "<<", ">>", "\.", "!", "@", "+", "-", "*",
  "=", "/", "%", "^", ">", "<"
  
}

// --------------------------------------------------------------------------------------------------------------------
// Separators
TOKEN: {
  
  "(", ")", "{", "}", "[", "]", ",", ";", ":", "\""
  
}

// --------------------------------------------------------------------------------------------------------------------
// Reserved Words
TOKEN: {
  
  "var", "set", "param", "if", "else", "main", "func", "for", "return", "while"
  
}

// --------------------------------------------------------------------------------------------------------------------
// Values

TOKEN: {
  
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])*  >
|  
  < REFERENCE: "@" <IDENTIFIER> ":" <IDENTIFIER> >
|
  < LIT_GENERAL: <LIT_NUMBER> | <LIT_CHAR> | <LIT_STRING> >
|
  < LIT_NUMBER: <LIT_DECIMAL> | <LIT_HEX> >
|
  < #LIT_DECIMAL: ["1"-"9"] (["0"-"9"])* >
|
  < #LIT_HEX: "0x" (["0"-"9","a"-"f","A"-"F"]){1,4} >
|
  < LIT_CHAR:
    "'"
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "'"
  >
|
  < LIT_STRING:
    "\""
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "\""
  >
  
  
}


// --------------------------------------------------------------------------------------------------------------------
// Grammar

void Program() :
{
  List<ParamDeclaration> paramDeclList = new ArrayList<ParamDeclaration>();
  List<FunctionDeclaration> funcDeclList = new ArrayList<FunctionDeclaration>();
  MainDeclaration mainDecl;
  ParamDeclaration pd;
  FunctionDeclaration fd;
}
{

  ( pd = ParamDeclaration() { paramDeclList.add(pd); } )*
  ( mainDecl = MainDeclaration() )
  ( fd = FunctionDeclaration() {funcDeclList.add(fd); } )*
  <EOF>
  { return new Program(paramDeclList, mainDecl, funcDeclList); }
}

void MainDeclaration() :
{
  StatementList statementList;
}
{
  "main" "{"
    ( statementList = StatementList() )
  "}"
  
  { return new MainDeclaration(statementList); }
}

void FunctionDeclaration() :
{
  ArgList argList;
  StatementList statementList;
}
{
  "func" <IDENTIFIER> "(" argList = ArgList() ")" "{"
    statementList = StatementList()
  "}"
  
  { return new FunctionDeclaration(argList, statementList); }
}

void ParamDeclaration() :
{
  Token id;
  Token lit;
}
{
 
  "param" (id = <IDENTIFIER>) "=" (lit = <LIT_GENERAL>) ";"
  
  { return new ParamDeclaration(id, lit); }
}

void ArgList() :
{
  ArgListHead head;
  List<ArgListTail> tail = new ArrayList<ArgListTail>();
  ArgListTail t;
}
{
  head = ArgListHead() ( t = ArgListTail() {tail.add(t); } )*
  
  { return new ArgList(head, tail); }
}

void ArgListHead() :
{
  Token id;
}
{
  "var" id = <IDENTIFIER>
  
  { return new Variable(id.image()); }
}

void ArgListTail() :
{
  Token id;
}
{
  "," "var" id = <IDENTIFIER>
  
  { return new Variable(id.image()); }
}

void StatementList() :
{
  List<StatementList> sl = new ArrayList<StatementList>();
  Statement st;
}
{
  
  (LOOKAHEAD(2) st = Statement() { sl.add(st); } )+
  
  { return new StatementList(sl); }
}

void Statement() :
{
  Operation op;
  ControlStructure cs;
}
{
  ( op = Operation() )
  { return new Operation(op); }
|
  ( cs = ControlStructure() )
  { return new ControlStructure(cs); }
}

void Operation() : 
{
  SetOperation sop;
  VarDeclaration vDecl;
  VarInitialization vInit;
  ReturnOperation retOp;
  Expression expr;
}
{
  (
    LOOKAHEAD(3) sop = SetOperation()
    { return new SetOperation(sop) }
  |
    LOOKAHEAD(3) vDecl = VarDeclaration()
    { return new VarDeclaration(vDecl) }
  |
    vInit = VarInitialization()
    { return new VarInitialization(vInit) }
  |
    retOp = ReturnOperation()
    { return new ReturnOperation(retOp) }
  |
    expr = Expression()
    { return new Expression(expr) }
  )
  ";"
}

void ControlStructure() :
{}
{
  ConditionalBranch()
|
  WhileLoop()
|
  ForLoop()
}

void SetOperation() :
{}
{
  "set" <IDENTIFIER> "=" Expression()
}

void VarDeclaration() :
{}
{
  "var" <IDENTIFIER>
}

void VarInitialization() :
{}
{
  "var" <IDENTIFIER> "=" Expression()
}

void ReturnOperation() :
{}
{
  "return" (Expression())?
}

void ConditionalBranch() :
{}
{
  "if" "(" Expression() ")" "{"
    StatementList()
  "}"
  
  
  ( LOOKAHEAD(2) 
    "else" "if" "(" Expression() ")" "{"
      StatementList()
    "}"
  )*
  
  (
    "else" "(" Expression() ")" "{"
      StatementList()
    "}"
  )?
}

void WhileLoop() :
{}
{
  "while" "(" Expression() ")" "{"
    StatementList()
  "}"
}

void ForLoop() :
{}
{
  "for" "(" (VarInitialization())? ";" Expression() ";" SetOperation() ")" "{"
    StatementList()
  "}"
}

void Expression() :
{}
{
  "(" Expression() ")" |
  "!" Expression() |
  
  LOOKAHEAD(3) ExpressionHead() "<<<" Expression() |
  LOOKAHEAD(3) ExpressionHead() ">>>" Expression() |
  LOOKAHEAD(3) ExpressionHead() "<<" Expression() |
  LOOKAHEAD(3) ExpressionHead() ">>" Expression() |
  
  LOOKAHEAD(3) ExpressionHead() "<=" Expression() |
  LOOKAHEAD(3) ExpressionHead() ">=" Expression() |
  LOOKAHEAD(3) ExpressionHead() "<" Expression() |
  LOOKAHEAD(3) ExpressionHead() ">" Expression() |
  
  LOOKAHEAD(3) ExpressionHead() "+" Expression() |
  LOOKAHEAD(3) ExpressionHead() "-" Expression() |
  LOOKAHEAD(3) ExpressionHead() "*" Expression() |
  LOOKAHEAD(3) ExpressionHead() "/" Expression() |
  LOOKAHEAD(3) ExpressionHead() "^" Expression() |
  LOOKAHEAD(3) ExpressionHead() "%" Expression()
}

void ExpressionHead() :
{}
{
  FunctionCall() |
  <IDENTIFIER> |
  <REFERENCE> |
  <LIT_GENERAL>
}

void FunctionCall() :
{}
{
  "\." <IDENTIFIER> "(" ( ValueList() )? ")"
}

void ValueList() :
{}
{
  Expression() ("," Expression() )*
}

