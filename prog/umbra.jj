options
{
  STATIC = false;
  COMMON_TOKEN_ACTION = true;
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

// --------------------------------------------------------------------------------------------------------------------
// Parser Declaration

PARSER_BEGIN(UmbraCmp)

import java.io.*;

public class UmbraCmp {

  private FileInputStream fin;
  private PrintWriter fout;

  public UmbraCmp(final FileInputStream fin, final PrintWriter fout) {
    this.fin = fin;
    this.fout = fout;
  }
  
  public static void main(String[] args) throws IOException {
    
    if(!checkFile(args)) {
      return;
    }
    
    // Get input/output file names
    final String inFileName = args[0];
    final String outFileName = inFileName.replaceFirst("[.][^.]+$", "") + ".syz";
    
    final FileInputStream fileIn = new FileInputStream(inFileName);
    final PrintWriter fileOut = new PrintWriter(outFileName);
    
    fileOut.println("# Compiled with UmbraCmp");
    
    final UmbraCmp compiler = new UmbraCmp(fileIn, fileOut);
    
    try {
      compiler.Program();
    } catch(ParseException pe) {
      System.err.println(pe.getMessage());
    }
    
    fileOut.close();
  }
  
  private static final boolean checkFile(String[] args) {
    if(args.length != 1) {
      printUsage();
      return false;
    }
    
    final File umbFile = new File(args[0]);
    if(!umbFile.exists()) {
      System.err.println("The file \"" + umbFile.getName() + "\" does not exist!");
      return false;
    }
    if(!args[0].endsWith(".umb")) {
      System.err.println("Pass a valid .umb file.");
    }
    
    return true;
  }
  
  private static final void printUsage() {
    System.err.println("Usage:\"java UmbraCmp <PATH_TO_UMB_FILE>\".");
  }

}

class CodeGenerator {
  
  public String getAsm(final String op) {
    return null;
  }
  
  private String translateExpression(final String expr) {
    return null;
  }
  
}

PARSER_END(UmbraCmp)

// --------------------------------------------------------------------------------------------------------------------
// Tokens

TOKEN_MGR_DECLS: {
  void CommonTokenAction(Token t) {
    System.out.println("Token: " + t.image);
  }
}

SKIP: {
  " "| "\t" | "\n" | "\r" | "\f"
}


// --------------------------------------------------------------------------------------------------------------------
// Comments

MORE :
{
  "#" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}



// --------------------------------------------------------------------------------------------------------------------
// Operators

TOKEN: {
  < OP_ASHIFTL:"<<<"> |
  < OP_ASHIFTR:">>>"> |
  < OP_LTE:"<="> |
  < OP_GTE:">="> |
  < OP_LSL:"<<"> |
  < OP_LSR:">>"> |
  < OP_PERIOD: "."> |
  < OP_BSLASH: "\\"> |
  < OP_EXPOINT: "!"> |
  < OP_ATSIGN: "@"> |
  < OP_PLUS:"+"> |
  < OP_HYPHEN:"-"> |
  < OP_ASTERISK:"*"> |
  < OP_EQUALS:"="> |
  < OP_FSLASH:"/"> |
  < OP_PERCENT: "%"> |
  < OP_CARET: "^"> |
  < OP_GT: ">"> |
  < OP_LT: "<">
}

// --------------------------------------------------------------------------------------------------------------------
// Separators
TOKEN: {
  < SEP_LPAREN:"("> |
  < SEP_RPAREN:")"> |
  < SEP_LBRACE:"{"> |
  < SEP_RBRACE:"}"> |
  < SEP_LSQBR:"["> |
  < SEP_RSQBR:"]"> |
  < SEP_COMMA: ","> |
  < SEP_SEMICOLON: ";"> |
  < SEP_COLON: ":"> |
  < SEP_DQUOTE: "\"">
}

// --------------------------------------------------------------------------------------------------------------------
// Reserved Words
TOKEN: {
  
  < RW_VAR: "var" > |
  < RW_SET: "set" > |
  < RW_PARAM: "param" > |
  < RW_IF: "if" > |
  < RW_ELSE: "else" > |
  < RW_MAIN: "main" > |
  < RW_FUNC: "func" > |
  < RW_FOR: "for" > |
  < RW_RETURN: "return" > |
  < RW_WHILE: "while" >
}

// --------------------------------------------------------------------------------------------------------------------
// Values

TOKEN: {
  
  < IDENTIFIER: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])*  >
|  
  < REFERENCE: "@" <IDENTIFIER> ":" <IDENTIFIER> >
|
  < LIT_GENERAL: <LIT_NUMBER> | <LIT_CHAR> | <LIT_STRING> >
|
  < LIT_NUMBER: <LIT_DECIMAL> | <LIT_HEX> >
|
  < #LIT_DECIMAL: ["1"-"9"] (["0"-"9"])* >
|
  < #LIT_HEX: "0x" (["0"-"9","a"-"f","A"-"F"]){1,4} >
|
  < LIT_CHAR:
    "'"
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "'"
  >
|
  < LIT_STRING:
    "\""
    (   
      (~["\"","\\","\n"]) | 
      ("\\" ( ["n","\\","'","\""]))
    )*
    "\""
  >
  
  
}


// --------------------------------------------------------------------------------------------------------------------
// Grammar

void Program() :
{}
{

  ( ParamDeclaration() )*
  ( FunctionDeclaration() )*
  MainDeclaration()
  ( FunctionDeclaration() )*
  <EOF>
    
}

void MainDeclaration() :
{}
{
  <RW_MAIN> <SEP_LBRACE>
    StatementList()
  <SEP_RBRACE>
}

void FunctionDeclaration() :
{}
{
  <RW_FUNC> <IDENTIFIER> <SEP_LPAREN> ArgList() <SEP_RPAREN> <SEP_LBRACE>
    StatementList()
  <SEP_RBRACE>
  
}

void ParamDeclaration() :
{}
{
 
  <RW_PARAM> <IDENTIFIER> <OP_EQUALS> <LIT_GENERAL> <SEP_SEMICOLON>
  
}

void ArgList() :
{}
{
  <RW_VAR> <IDENTIFIER> (<SEP_COMMA> <RW_VAR> <IDENTIFIER>)*
}

void StatementList() :
{}
{
  Statement()
  (LOOKAHEAD(2) StatementList() )*
}

void Statement() :
{}
{
  ( Operation() ) |
  ( ControlStructure() )
}

void Operation() : 
{}
{
  (
    LOOKAHEAD(3) SetOperation() |
    LOOKAHEAD(3) VarDeclaration() |
    VarInitialization() |
    ReturnOperation() |
    Expression()
  )
  <SEP_SEMICOLON>
}

void ControlStructure() :
{}
{
  ConditionalBranch() |
  WhileLoop() |
  ForLoop()
}

void SetOperation() :
{}
{
  <RW_SET> <IDENTIFIER> <OP_EQUALS> Expression()
}

void VarDeclaration() :
{}
{
  <RW_VAR> <IDENTIFIER>
}

void VarInitialization() :
{}
{
  <RW_VAR> <IDENTIFIER> <OP_EQUALS> Expression()
}

void ReturnOperation() :
{}
{
  <RW_RETURN> (Expression())?
}

void ConditionalBranch() :
{}
{
  <RW_IF> <SEP_LPAREN> Expression() <SEP_RPAREN> <SEP_LBRACE>
    StatementList()
  <SEP_RBRACE>
  
  
  ( LOOKAHEAD(2) 
    <RW_ELSE> <RW_IF> <SEP_LPAREN> Expression() <SEP_RPAREN> <SEP_LBRACE>
      StatementList()
    <SEP_RBRACE>
  )*
  
  (
    <RW_ELSE> <SEP_LPAREN> Expression() <SEP_RPAREN> <SEP_LBRACE>
      StatementList()
    <SEP_RBRACE>
  )?
}

void WhileLoop() :
{}
{
  <RW_WHILE> <SEP_LPAREN> Expression() <SEP_RPAREN> <SEP_LBRACE>
    StatementList()
  <SEP_RBRACE>
}

void ForLoop() :
{}
{
  <RW_FOR> <SEP_LPAREN> (VarInitialization())? <SEP_SEMICOLON> Expression() <SEP_SEMICOLON> SetOperation() <SEP_RPAREN> <SEP_LBRACE>
    StatementList()
  <SEP_RBRACE>
}

void Expression() :
{}
{
  <SEP_LPAREN> Expression() <SEP_RPAREN> |
  <OP_EXPOINT> Expression() |
  
  LOOKAHEAD(3) ExpressionHead() <OP_ASHIFTL> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_ASHIFTR> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_LSL> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_LSR> Expression() |
  
  LOOKAHEAD(3) ExpressionHead() <OP_LTE> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_GTE> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_LT> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_GT> Expression() |
  
  LOOKAHEAD(3) ExpressionHead() <OP_PLUS> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_HYPHEN> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_ASTERISK> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_FSLASH> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_CARET> Expression() |
  LOOKAHEAD(3) ExpressionHead() <OP_PERCENT> Expression()
}

void ExpressionHead() :
{}
{
  FunctionCall() |
  <IDENTIFIER> |
  <REFERENCE> |
  <LIT_GENERAL>
}

void FunctionCall() :
{}
{
  <OP_PERIOD> <IDENTIFIER> <SEP_LPAREN> ( ValueList() )? <SEP_RPAREN>
}

void ValueList() :
{}
{
  Expression() (<SEP_COMMA> Expression() )*
}

